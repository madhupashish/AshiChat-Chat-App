'use strict';

module.exports = exports = testBinary;
exports.usage = 'Tests that the binary.node can be required';

const path = require('path');
const log = require('npmlog');
const cp = require('child_process');
const versioning = require('./util/versioning.js');
const napi = require('./util/napi.js');

function testBinary(gyp, argv, callback) {
  const args = [];
  const options = {};
  let shellCmd = process.execPath;
  const packageJson = gyp.package_json;
  const napiBuildVersion = napi.getNapiBuildVersionFromCommandArgs(argv);
  const opts = versioning.evaluate(packageJson, gyp.opts, napiBuildVersion);

  // Skip validation for runtimes we don't explicitly support (like Electron)
  if (opts.runtime && opts.runtime !== 'node-webkit' && opts.runtime !== 'node') {
    return callback();
  }

  const nw = (opts.runtime && opts.runtime === 'node-webkit');

  // Ensure on Windows that '/' is used for the require path
  const binaryModule = opts.module.replace(/\\/g, '/');

  if (process.arch !== opts.target_arch || process.platform !== opts.target_platform) {
    let msg = 'skipping validation since host platform/arch (';
    msg += process.platform + '/' + process.arch + ')';
    msg += ' does not match target (';
    msg += opts.target_platform + '/' + opts.target_arch + ')';
    log.info('validate', msg);
    return callback();
  }

  if (nw) {
    options.timeout = 5000;

    if (process.platform === 'darwin') {
      shellCmd = 'node-webkit';
    } else if (process.platform === 'win32') {
      shellCmd = 'nw.exe';
    } else {
      shellCmd = 'nw';
    }

    const modulePath = path.resolve(binaryModule);
    const appDir = path.join(__dirname, 'util', 'nw-pre-gyp');
    args.push(appDir);
    args.push(modulePath);

    log.info('validate', "Running test command: '" + shellCmd + ' ' + args.join(' ') + "'");

    cp.execFile(shellCmd, args, options, (err, stdout, stderr) => {
      // Check for normal timeout for node-webkit
      if (err) {
        if (err.killed === true && err.signal && err.signal.indexOf('SIG') > -1) {
          return callback();
        }

        const stderrLog = stderr.toString();
        log.info('stderr', stderrLog);

        if (/^\s*Xlib:\s*extension\s*"RANDR"\s*missing\s*on\s*display\s*":\d+\.\d+"\.\s*$/.test(stderrLog)) {
          log.info('RANDR', 'stderr contains only RANDR error, ignored');
          return callback();
        }

        return callback(err);
      }

      return callback();
    });

    return;
  }

  args.push('--eval');
  args.push("require('" + binaryModule.replace(/'/g, '\'') + "')");

  log.info('validate', "Running test command: '" + shellCmd + ' ' + args.join(' ') + "'");

  cp.execFile(shellCmd, args, options, (err, stdout, stderr) => {
    if (err) {
      return callback(err, { stdout: stdout, stderr: stderr });
    }

    return callback();
  });
}

module.exports = exports;
