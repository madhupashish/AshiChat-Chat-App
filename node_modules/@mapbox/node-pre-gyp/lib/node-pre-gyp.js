'use strict';

module.exports = exports;

const fs = require('fs');
const path = require('path');
const nopt = require('nopt');
const log = require('npmlog');
const napi = require('./util/napi.js');

exports.mockS3Http = require('./util/s3_setup').get_mockS3Http();
exports.mockS3Http('on');
const mocking = exports.mockS3Http('get');

// ... (other dependencies)

function Run({ packageJsonPath = './package.json', argv }) {
  this.packageJsonPath = packageJsonPath;
  this.commands = {};
  this.binaryHostSet = false;

  const self = this;
  cliCommands.forEach((command) => {
    self.commands[command] = function (argvx, callback) {
      log.verbose('command', command, argvx);
      return require('./' + command)(self, argvx, callback);
    };
  });

  this.parseArgv(argv);
}

// ... (other prototype methods)

proto.setBinaryHostProperty = function (command) {
  if (this.binaryHostSet || !this.packageJson || !this.packageJson.binary || this.packageJson.binary.host) {
    return '';
  }

  const p = this.packageJson;
  const target = command === 'publish' || command === 'unpublish' ? 'staging_host' : 'production_host';

  const npgS3Host = process.env.node_pre_gyp_s3_host;
  const s3HostOption = this.opts['s3_host'] || npgS3Host;

  if (s3HostOption === 'staging' || s3HostOption === 'production') {
    p.binary.host = p.binary[`${s3HostOption}_host`];
  } else if (s3HostOption) {
    throw new Error(`Invalid s3_host ${s3HostOption}`);
  } else {
    p.binary.host = p.binary[target];
  }

  this.binaryHostSet = true;
  return p.binary.host;
};

// ... (other prototype methods)
