'use strict';

process.title = 'node-pre-gyp';

const nodePreGyp = require('../');
const log = require('npmlog');

const prog = new nodePreGyp.Run({ argv: process.argv });
let completed = false;

if (prog.todo.length === 0) {
  if (~process.argv.indexOf('-v') || ~process.argv.indexOf('--version')) {
    console.log('v%s', prog.version);
    process.exit(0);
  } else if (~process.argv.indexOf('-h') || ~process.argv.indexOf('--help')) {
    console.log('%s', prog.usage());
    process.exit(0);
  }
  console.log('%s', prog.usage());
  process.exit(1);
}

if (prog.opts && Object.hasOwnProperty.call(prog, 'color') && !prog.opts.color) {
  log.disableColor();
}

log.info('it worked if it ends with', 'ok');
log.verbose('cli', process.argv);
log.info('using', process.title + '@%s', prog.version);
log.info('using', 'node@%s | %s | %s', process.versions.node, process.platform, process.arch);

const dir = prog.opts.directory;
if (dir) {
  changeDirectory(dir);
}

function run() {
  const command = prog.todo.shift();
  if (!command) {
    completed = true;
    log.info('ok');
    return;
  }

  const target = prog.setBinaryHostProperty(command.name);
  if (target && ['install', 'publish', 'unpublish', 'info'].indexOf(command.name) >= 0) {
    log.info('using binary.host: ' + prog.package_json.binary.host);
  }

  prog.commands[command.name](command.args, function(err) {
    if (err) {
      handleCommandError(command.name, err);
      return process.exit(1);
    }
    const argsArray = [].slice.call(arguments, 1);
    if (argsArray.length) {
      console.log.apply(console, argsArray);
    }
    process.nextTick(run);
  });
}

process.on('exit', (code) => {
  if (!completed && !code) {
    log.error('Completion callback never invoked!');
    logErrorMessage();
    process.exit(6);
  }
});

process.on('uncaughtException', (err) => {
  log.error('UNCAUGHT EXCEPTION');
  log.error('stack', err.stack);
  logErrorMessage();
  process.exit(7);
});

function changeDirectory(directory) {
  const fs = require('fs');
  try {
    const stat = fs.statSync(directory);
    if (stat.isDirectory()) {
      log.info('chdir', directory);
      process.chdir(directory);
    } else {
      log.warn('chdir', directory + ' is not a directory');
    }
  } catch (e) {
    if (e.code === 'ENOENT') {
      log.warn('chdir', directory + ' is not a directory');
    } else {
      log.warn('chdir', 'error during chdir() "%s"', e.message);
    }
  }
}

function handleCommandError(commandName, err) {
  log.error(commandName + ' error');
  log.error('stack', err.stack);
  logErrorMessage();
  log.error('not ok');
  console.log(err.message);
}

function logErrorMessage() {
  const os = require('os');
  log.error('System', os.type() + ' ' + os.release());
  log.error('command', process.argv.map(JSON.stringify).join(' '));
  log.error('cwd', process.cwd());
  log.error('node -v', process.version);
  log.error(process.title + ' -v', 'v' + prog.package.version);
}

run();
