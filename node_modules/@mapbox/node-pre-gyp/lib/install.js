'use strict';

const fs = require('fs');
const path = require('path');
const log = require('npmlog');
const existsAsync = fs.exists || path.exists;
const versioning = require('./util/versioning.js');
const napi = require('./util/napi.js');
const makeDir = require('make-dir');
const fetch = require('node-fetch');
const tar = require('tar');

let npgVersion = 'unknown';
try {
  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');
  npgVersion = JSON.parse(ownPackageJSON).version;
} catch (e) {
  // do nothing
}

module.exports = exports = install;

exports.usage = 'Attempts to install pre-built binary for module';

function install(gyp, argv, callback) {
  const packageJson = gyp.package_json;
  const napiBuildVersion = napi.getNapiBuildVersionFromCommandArgs(argv);
  const sourceBuild = gyp.opts['build-from-source'] || gyp.opts.build_from_source;
  const updateBinary = gyp.opts['update-binary'] || gyp.opts.update_binary;
  const shouldDoSourceBuild = sourceBuild === packageJson.name || (sourceBuild === true || sourceBuild === 'true');

  if (shouldDoSourceBuild) {
    log.info('build', 'requesting source compile');
    return doBuild(gyp, argv, callback);
  } else {
    const fallbackToBuild = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;
    let shouldDoFallbackBuild = fallbackToBuild === packageJson.name || (fallbackToBuild === true || fallbackToBuild === 'true');

    if (process.env.npm_config_argv) {
      const cooked = JSON.parse(process.env.npm_config_argv).cooked;
      const match = cooked.indexOf('--fallback-to-build');
      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {
        shouldDoFallbackBuild = false;
        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');
      }
    }

    let opts;
    try {
      opts = versioning.evaluate(packageJson, gyp.opts, napiBuildVersion);
    } catch (err) {
      return callback(err);
    }

    opts.ca = gyp.opts.ca;
    opts.cafile = gyp.opts.cafile;

    const from = opts.hosted_tarball;
    const to = opts.module_path;
    const binaryModule = path.join(to, opts.module_name + '.node');

    existsAsync(binaryModule, (found) => {
      if (!updateBinary) {
        if (found) {
          log.info('install', `Success: "${binaryModule}" already installed`);
          log.info('install', 'Pass --update-binary to reinstall or --build-from-source to recompile');
          return callback();
        }
        log.info('check', `checked for "${binaryModule}" (not found)`);
      }

      makeDir(to)
        .then(() => {
          const fileName = from.startsWith('file://') && from.slice('file://'.length);
          if (fileName) {
            extractFromLocal(fileName, to, afterPlace);
          } else {
            placeBinary(from, to, opts, afterPlace);
          }
        })
        .catch((err) => {
          afterPlace(err);
        });

      function afterPlace(err) {
        if (err && shouldDoFallbackBuild) {
          printFallbackError(err, opts, packageJson);
          return doBuild(gyp, argv, callback);
        } else if (err) {
          return callback(err);
        } else {
          log.info('install', `Success: "${binaryModule}" is installed via remote`);
          return callback();
        }
      }
    });
  }
}

function placeBinary(uri, targetDir, opts, callback) {
  // ... (unchanged)
}

function extractFromLocal(from, targetDir, callback) {
  // ... (unchanged)
}

function doBuild(gyp, argv, callback) {
  const args = ['rebuild'].concat(argv);
  gyp.todo.push({ name: 'build', args: args });
  process.nextTick(callback);
}

function printFallbackError(err, opts, packageJson) {
  // ... (unchanged)
}
