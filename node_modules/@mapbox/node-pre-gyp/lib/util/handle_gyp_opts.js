'use strict';

module.exports = exports = handleGypOpts;

const versioning = require('./versioning.js');
const napi = require('./napi.js');

const NODE_PRE_GYP_OPTIONS_PREFIX = '--';

function handleGypOpts(gyp, argv, callback) {
  const nodePreGypOptions = [];
  const shareWithNodeGyp = [
    'module',
    'module_name',
    'module_path',
    'napi_version',
    'node_abi_napi',
    'napi_build_version',
    'node_napi_label'
  ];

  const napiBuildVersion = napi.getNapiBuildVersionFromCommandArgs(argv);
  const opts = versioning.evaluate(gyp.package_json, gyp.opts, napiBuildVersion);

  shareWithNodeGyp.forEach((key) => {
    const val = opts[key];
    if (val) {
      nodePreGypOptions.push(`${NODE_PRE_GYP_OPTIONS_PREFIX}${key}=${val}`);
    } else if (key === 'napi_build_version') {
      nodePreGypOptions.push(`${NODE_PRE_GYP_OPTIONS_PREFIX}${key}=0`);
    } else {
      return callback(new Error(`Option ${key} required but not found by node-pre-gyp`));
    }
  });

  const unparsedOptions = [];
  let doubleHyphenFound = false;
  gyp.opts.argv.original.forEach((opt) => {
    if (doubleHyphenFound) {
      unparsedOptions.push(opt);
    }
    if (opt === '--') {
      doubleHyphenFound = true;
    }
  });

  const nodeGypOptions = gyp.opts.argv.cooked
    .filter((value) => value.length > 2 && value.slice(0, 2) === NODE_PRE_GYP_OPTIONS_PREFIX)
    .map((value) => {
      const key = value.slice(2);
      const val = gyp.opts.argv.cooked[gyp.opts.argv.cooked.indexOf(value) + 1];
      return val && val.indexOf(NODE_PRE_GYP_OPTIONS_PREFIX) === -1
        ? `${NODE_PRE_GYP_OPTIONS_PREFIX}${key}=${val}`
        : value;
    });

  const result = { opts, gyp: nodeGypOptions, pre: nodePreGypOptions, unparsed: unparsedOptions };
  return callback(null, result);
}
