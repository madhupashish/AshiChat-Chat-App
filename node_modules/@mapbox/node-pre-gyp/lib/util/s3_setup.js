'use strict';

const url = require('url');
const fs = require('fs');
const path = require('path');
const AWS = require('aws-sdk');
const AWSMock = require('mock-aws-s3');
const nock = require('nock');

module.exports = exports = {
  detect,
  get_s3,
  get_mockS3Http
};

function detect(opts, config) {
  const to = opts.hosted_path;
  const uri = url.parse(to);
  config.prefix = (!uri.pathname || uri.pathname === '/') ? '' : uri.pathname.replace('/', '');
  if (opts.bucket && opts.region) {
    config.bucket = opts.bucket;
    config.region = opts.region;
    config.endpoint = opts.host;
    config.s3ForcePathStyle = opts.s3ForcePathStyle;
  } else {
    const parts = uri.hostname.split('.s3');
    const bucket = parts[0];
    if (!bucket) {
      return;
    }
    if (!config.bucket) {
      config.bucket = bucket;
    }
    if (!config.region) {
      const region = parts[1].slice(1).split('.')[0];
      config.region = (region === 'amazonaws') ? 'us-east-1' : region;
    }
  }
}

function get_s3(config) {
  if (process.env.node_pre_gyp_mock_s3) {
    const os = require('os');

    AWSMock.config.basePath = `${os.tmpdir()}/mock`;
    const s3 = AWSMock.S3();

    const wcb = (fn) => (err, ...args) => {
      if (err && err.code === 'ENOENT') {
        err.code = 'NotFound';
      }
      return fn(err, ...args);
    };

    return {
      listObjects(params, callback) {
        return s3.listObjects(params, wcb(callback));
      },
      headObject(params, callback) {
        return s3.headObject(params, wcb(callback));
      },
      deleteObject(params, callback) {
        return s3.deleteObject(params, wcb(callback));
      },
      putObject(params, callback) {
        return s3.putObject(params, wcb(callback));
      }
    };
  }

  AWS.config.update(config);
  const s3 = new AWS.S3();

  return {
    listObjects(params, callback) {
      return s3.listObjects(params, callback);
    },
    headObject(params, callback) {
      return s3.headObject(params, callback);
    },
    deleteObject(params, callback) {
      return s3.deleteObject(params, callback);
    },
    putObject(params, callback) {
      return s3.putObject(params, callback);
    }
  };
}

function get_mockS3Http() {
  let mock_s3 = false;

  if (!process.env.node_pre_gyp_mock_s3) {
    return () => mock_s3;
  }

  const host = 'https://mapbox-node-pre-gyp-public-testing-bucket.s3.us-east-1.amazonaws.com';
  const mockDir = process.env.node_pre_gyp_mock_s3 + '/mapbox-node-pre-gyp-public-testing-bucket';

  const mock_http = () => {
    function get(uri, requestBody) {
      const filepath = path.join(mockDir, uri.replace('%2B', '+'));

      try {
        fs.accessSync(filepath, fs.constants.R_OK);
      } catch (e) {
        return [404, 'not found\n'];
      }

      return [200, fs.createReadStream(filepath)];
    }

    return nock(host)
      .persist()
      .get(() => mock_s3)
      .reply(get);
  };

  mock_http(nock, host, mockDir);

  const mockS3Http = (action) => {
    const previous = mock_s3;
    if (action === 'off') {
      mock_s3 = false;
    } else if (action === 'on') {
      mock_s3 = true;
    } else if (action !== 'get') {
      throw new Error(`illegal action for setMockHttp ${action}`);
    }
    return previous;
  };

  return mockS3Http;
}
