'use strict';

const path = require('path');
const semver = require('semver');
const url = require('url');
const detect_libc = require('detect-libc');
const napi = require('./napi.js');

let abi_crosswalk;

// Set a fake ABI crosswalk for unit testing
if (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {
  abi_crosswalk = require(process.env.NODE_PRE_GYP_ABI_CROSSWALK);
} else {
  abi_crosswalk = require('./abi_crosswalk.json');
}

const major_versions = {};
Object.keys(abi_crosswalk).forEach((v) => {
  const major = v.split('.')[0];
  if (!major_versions[major]) {
    major_versions[major] = v;
  }
});

function get_electron_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error('get_electron_abi requires a valid runtime arg');
  }
  if (typeof target_version === 'undefined') {
    throw new Error('Empty target version is not supported if electron is the target.');
  }
  const sem_ver = semver.parse(target_version);
  return runtime + '-v' + sem_ver.major + '.' + sem_ver.minor;
}

function get_node_webkit_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error('get_node_webkit_abi requires a valid runtime arg');
  }
  if (typeof target_version === 'undefined') {
    throw new Error('Empty target version is not supported if node-webkit is the target.');
  }
  return runtime + '-v' + target_version;
}

function get_node_abi(runtime, versions) {
  if (!runtime) {
    throw new Error('get_node_abi requires a valid runtime arg');
  }
  if (!versions) {
    throw new Error('get_node_abi requires a valid process.versions object');
  }
  const sem_ver = semver.parse(versions.node);
  if (sem_ver.major === 0 && sem_ver.minor % 2) {
    return runtime + '-v' + versions.node;
  } else {
    return versions.modules ? runtime + '-v' + (+versions.modules) : 'v8-' + versions.v8.split('.').slice(0, 2).join('.');
  }
}

function get_runtime_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error('get_runtime_abi requires a valid runtime arg');
  }
  if (runtime === 'node-webkit') {
    return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);
  } else if (runtime === 'electron') {
    return get_electron_abi(runtime, target_version || process.versions.electron);
  } else {
    if (runtime !== 'node') {
      throw new Error("Unknown Runtime: '" + runtime + "'");
    }
    if (!target_version) {
      return get_node_abi(runtime, process.versions);
    } else {
      let cross_obj;

      if (abi_crosswalk[target_version]) {
        cross_obj = abi_crosswalk[target_version];
      } else {
        const target_parts = target_version.split('.').map((i) => +i);
        if (target_parts.length !== 3) {
          throw new Error('Unknown target version: ' + target_version);
        }

        const major = target_parts[0];
        let minor = target_parts[1];
        let patch = target_parts[2];

        if (major === 1) {
          while (true) {
            if (minor > 0) --minor;
            if (patch > 0) --patch;
            const new_iojs_target = '' + major + '.' + minor + '.' + patch;
            if (abi_crosswalk[new_iojs_target]) {
              cross_obj = abi_crosswalk[new_iojs_target];
              console.log('Warning: node-pre-gyp could not find an exact match for ' + target_version);
              console.log('Warning: but node-pre-gyp successfully chose ' + new_iojs_target + ' as ABI compatible target');
              break;
            }
            if (minor === 0 && patch === 0) {
              break;
            }
          }
        } else if (major >= 2) {
          if (major_versions[major]) {
            cross_obj = abi_crosswalk[major_versions[major]];
            console.log('Warning: node-pre-gyp could not find an exact match for ' + target_version);
            console.log('Warning: but node-pre-gyp successfully chose ' + major_versions[major] + ' as ABI compatible target');
          }
        } else if (major === 0) {
          if (target_parts[1] % 2 === 0) {
            while (--patch > 0) {
              const new_node_target = '' + major + '.' + minor + '.' + patch;
              if (abi_crosswalk[new_node_target]) {
                cross_obj = abi_crosswalk[new_node_target];
                console.log('Warning: node-pre-gyp could not find an exact match for ' + target_version);
                console.log('Warning: but node-pre-gyp successfully chose ' + new_node_target + ' as ABI compatible target');
                break;
              }
            }
          }
        }
      }

      if (!cross_obj) {
        throw new Error('Unsupported target version: ' + target_version);
      }

      const versions_obj = {
        node: target_version,
        v8: cross_obj.v8 + '.0',
        modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined
      };

      return get_node_abi(runtime, versions_obj);
    }
  }
}

const required_parameters = [
  'module_name',
  'module_path',
  'host'
];

function validate_config(package_json, opts) {
  const msg = package_json.name + ' package.json is not node-pre-gyp ready:\n';
  const missing = [];

  if (!package_json.main) missing.push('main');
  if (!package_json.version) missing.push('version');
  if (!package_json.name) missing.push('name');
  if (!package_json.binary) missing.push('binary');

  const o = package_json.binary;

  if (o) {
    required_parameters.forEach((p) => {
      if (!o[p] || typeof o[p] !== 'string') {
        missing.push('binary.' + p);
      }
    });
  }

  if (missing.length >= 1) {
    throw new Error(msg + 'package.json must declare these properties: \n' + missing.join('\n'));
  }

  if (o) {
    const protocol = url.parse(o.host).protocol;
    if (protocol === 'http:') {
      throw new Error("'host' protocol (" + protocol + ") is invalid - only 'https:' is accepted");
    }
  }

  napi.validate_package_json(package_json, opts);
}

function eval_template(template, opts) {
  Object.keys(opts).forEach((key) => {
    const pattern = '{' + key + '}';
    while (template.indexOf(pattern) > -1) {
      template = template.replace(pattern, opts[key]);
    }
  });
  return template;
}

function fix_slashes(pathname) {
  if (pathname.slice(-1
